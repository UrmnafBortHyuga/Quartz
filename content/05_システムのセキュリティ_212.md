---
aliases: 
created: 2024-06-22T08:48 (UTC +09:00)
tags:
  - LPIC202
---
# 14.1 ルータを構成する(パケットフィルタリング)
TCP/IPでは、ネットワーク上を流れる情報はパケット単位で伝送されます。カーネルが処理するパケットの情報を調べて不要なパケットを通過させたり遮断したりすることを**パケットフィルタリング**といいます。

パケットフィルタリングは基本的に、入力（INPUT）、出力（OUTPUT）、転送（FORWARD）の3か所で行います。それぞれを**INPUTチェイン**、**OUTPUTチェイン**、**FORWARDチェイン**といいます。**チェイン**というのは、パケットを検査するための一連のルールセットのことで、それらのチェインに新しいルールを追加したり、あるいはカスタムチェインを追加したりして設定します。ネットワークインターフェースを通過するパケットは、それぞれのチェインのルールに適合するか検査され、その結果破棄されたり、通過が許可されたりします。

いくつかのチェインのセットを**テーブル**といいます。デフォルトのfilterテーブル、新しい接続を開くパケットのためのnatテーブル、特別なパケット変換に使われるmangleテーブルがあります。

表14-1　主なテーブルとデフォルトチェイン

|テーブル|デフォルトチェイン|
|---|---|
|filter|INPUT、OUTPUT、FORWARD|
|nat|PREROUTING、POSTROUTING、OUTPUT|
|mangle|INPUT、OUTPUT、FORWARD、PREROUTING、POSTROUTING|

![[00700.jpeg]]
図14-1　iptables

## 14.1.1 iptablesコマンド
パケットフィルタリングはLinuxカーネルが備える機能です。**iptablesコマンド**を使ってパケットフィルタリングの設定を行います。

_書式：_ `iptables -[AD] チェイン ルール`

_書式：_ `iptables -P チェイン ターゲット`

_書式：_ `iptables -[LFNX] [チェイン]`

_書式：_ `iptables -I チェイン [ルール番号] ルール`


表14-2　iptablesの主なコマンド、チェイン、ターゲット、ルール、オプション

| コマンド           | 説明                          |
| -------------- | --------------------------- |
| -A             | 指定したチェインの最後にルールを追加する        |
| -D             | 指定したチェインからルールを削除する          |
| -P             | 指定したチェインのポリシーを変更する          |
| -L [チェイン]      | ルールのリストを表示する                |
| -N チェイン        | 指定した名前のユーザー定義チェインを作成する      |
| -X チェイン        | 指定したユーザー定義チェインを削除する         |
| -I             | ルール番号を指定してルールを挿入する          |
| -F チェイン        | 指定したチェイン内のルールをすべて削除する       |

| チェイン           | 説明                          |
| -------------- | --------------------------- |
| INPUT          | ホストに入ってくるパケット               |
| OUTPUT         | ローカルマシンで生成されたパケット           |
| FORWARD        | ホストを経由するパケット                |
| PREROUTING     | 入ってきたパケットを変換                |
| POSTROUTING    | 出て行くパケットを変換                 |

| ターゲット          | 説明                          |
| -------------- | --------------------------- |
| ACCEPT         | パケットの通過を許可                  |
| DROP           | パケットを破棄                     |
| REJECT         | パケットを拒否（送信元に通知）             |
| MASQUERADE     | 送信元IPアドレスとポート番号の変換          |
| SNAT           | 送信元IPアドレスの変換                |
| DNAT           | 送信先IPアドレスの変換                |
| LOG            | ログに出力                       |

| ルール            | 説明                          |
| -------------- | --------------------------- |
| -s 送信元         | 送信元のIPアドレス                  |
| -d 送信先         | 送信先のIPアドレス                  |
| --sport ポート番号  | 送信元のポート番号                   |
| --dport ポート番号  | 送信先のポート番号                   |
| --to           | 宛先を指定（IPアドレス:ポート番号）         |
| -j ターゲット       | 適用されるターゲット                  |
| -p プロトコル       | プロトコル（tcp、udp、icmp、allいずれか） |
| -i インターフェース名   | 入力インターフェース（eth0、ppp0など）     |
| -o インターフェース名   | 出力インターフェース（eth0、ppp0など）     |

| オプション          | 説明                          |
| -------------- | --------------------------- |
| -v             | 詳細に表示する                     |
| -n             | 数値で表示する（IPアドレスやポート番号など）     |
| --line-numbers | ルール番号を表示する                  |

次の例では、FORWARDチェインのポリシー（デフォルトのターゲット）をDROP に変更しています。

```
# iptables -P FORWARD DROP
```

次の例では、192.168.120.0/24から送られてきたICMPパケットを拒否しています。

```
# iptables -A INPUT -p icmp -s 192.168.120.0/24 -j REJECT
```

ターゲットがREJECTの場合、パケットの送信元にエラーが通知されます。次の例は、上記の設定を行ったホストに対してpingコマンドを実行したところです。

```
$ ping 172.16.0.253
PING 172.16.0.253 (172.16.0.253) 56(84) bytes of data.
From 172.16.0.253 icmp_seq=0 Destination Port Unreachable
From 172.16.0.253 icmp_seq=1 Destination Port Unreachable
From 172.16.0.253 icmp_seq=2 Destination Port Unreachable
From 172.16.0.253 icmp_seq=3 Destination Port Unreachable

--- 172.16.0.253 ping statistics ---
4 packets transmitted, 0 received, +4 errors, 100% packet loss, time 3022ms, pipe 2

```

通知されないようにするには、REJECTではなくDROPを使います。

```
# iptables -A INPUT -p icmp -s 192.168.120.0/24 -j DROP
```

パケットフィルタリングの挙動をログに記録する場合は、LOGターゲットを使います。パケットフィルタリングはカーネルの機能なので、/etc/syslog.confや/etc/rsyslog.confの設定によって記録されるログファイルが決まります【注1】。デフォルトのログ出力ではログが識別しにくいので、何らかのプレフィックスを付けるとよいでしょう。次の例では、条件に当てはまるパケットを「Telnet Trying...」というプレフィックスとともにログに出力し、破棄しています。

```
# iptables -A INPUT -p tcp --dport 23 -j LOG --log-prefix "Telnet Trying..."
# iptables -A INPUT -p tcp --dport 23 -j DROP
```

ログには次のように出力されます。

```
# journalctl
(省略)
1月 12 14:51:41 ubuntu16 kernel: Telnet Trying... IN=enp2s0 OUT= MAC=00:11:22:33:44:55:66:77:88:99:aa:bb:08:00 SRC=192.168.1.21 
DST=192.168.1.33 LEN=48 TOS=0x00 PREC=0x00 TTL=128 ID=611 DF PROTO=TCP SPT=50491 DPT=23 WINDOW=8192 RES=0x00 SYN URGP=0
```

iptablesの設定は、Red Hat系のディストリビューションでは次のようにして保存します。

```
# service iptables save
```

あるいは、**iptables-saveコマンド**の出力を/etc/sysconfig/iptablesに保存します。

```
# iptables-save > /etc/sysconfig/iptables
```

Ubuntuでは、iptables-saveコマンドの出力を/etc/iptables/rules.v4に保存します。

```
# iptables-save > /etc/iptables/rules.v4
```

## firewalld

**コラム**
CentOS 7では、ファイヤウォールの仕組みとしてfirewalldが採用されており、デフォルトではiptablesは利用できません。iptablesを利用するには、iptables-services パッケージをインストールし、firewalldサービスは停止しておく必要があります。設定はfirewall-cmdコマンドで行います。

Ubuntuでは、iptablesを使って設定してもかまいませんが、より簡単にファイヤウォールの設定ができるufwコマンドを使うのが一般的です。

## 14.1.2 ポート転送

ホストがインターネットと内部LANとの間にある場合、インターネットから届いたパケットの送信先ポート番号を変更して内部に転送することができます。たとえば、インターネットからポート8080 番宛に届いたパケットを（インターネット側はeth1）、LAN内（172.16.0.0/16）のホスト172.16.0.2の80 番ポートに届くように設定するには、次のようにします。

```
# iptables -A FORWARD -d 172.16.0.2 -p tcp --dport 80 -j ACCEPT
# iptables -t nat -A PREROUTING -p tcp --dport 8080 -i eth1 -j DNAT --to 172.16.0.2:80
```


## 14.1.3 ip6tablesコマンド


IPv4についてはiptablesコマンドで設定を行いますが、IPv6は**ip6tablesコマンド**を使います。ip6tablesコマンドの使い方はiptablesコマンドと同じです。次の例では、ルールのリストを表示しています。

```
# ip6tables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination
ACCEPT     all      anywhere             anywhere             state RELATED,ESTABLISHED
ACCEPT     ipv6-icmp anywhere             anywhere
ACCEPT     all      anywhere             anywhere
ACCEPT     tcp      anywhere             anywhere             state NEW tcp dpt:ssh
REJECT     all      anywhere             anywhere             reject-with icmp6-adm-prohibited

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination
REJECT     all      anywhere             anywhere             reject-with icmp6-adm-prohibited

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination

```

ip6tablesの設定は、Red Hat系のディストリビューションでは次のようにして保存します。

```
# service ip6tables save
```

あるいは、**ip6tables-saveコマンド**の出力を/etc/sysconfig/ip6tablesに保存します。

```
# ip6tables-save > /etc/sysconfig/ip6tables
```

Ubuntuでは、ip6tables-saveコマンドの出力を/etc/iptables/rules.v6に保存します。

```
# ip6tables-save > /etc/iptables/rules.v6
```


# 14.2 ルータの構成

Linuxホストをルータとして利用することもできます。そのためには、**ルーティングテーブル**を適切に設定し、パケット転送が処理されるよう設定する必要があります。

図14-2は、ルータによるルーティングの概念を表しています。ルータはルーティングテーブルに基づいてパケットの転送を行います。
![[00716.jpeg]]
図14-2　ルーティング

## 14.2.1 ルーティングテーブル

ルーティングテーブルを表示するには、**route**コマンドもしくは**netstat -rコマンド**を実行します。

```
$ route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         gateway         0.0.0.0         UG    100    0        0 eth0
192.168.11.0    0.0.0.0         255.255.255.0   U     100    0        0 eth0
```

```
$ netstat -r
Kernel IP routing table
Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
default         gateway         0.0.0.0         UG      0   0        0    eth0
192.168.11.0    0.0.0.0         255.255.255.0   U       0   0        0    eth0
```

ルーティングテーブルに格納されるエントリには、静的経路と動的経路があります【注2】。静的経路は、routeコマンドを使って設定していく経路です。動的経路は、ルータ同士が情報を交換することで自律的に構成していく経路です。動的経路を構成するプロトコルとしては、RIP（Routing Information Protocol）やRIPv2、BGP（Border Gateway Protocol）、OSPF（Open Shortest Path First）などがあります。Linuxで動作するルーティングソフトウェアとしては**Quagga**があります。動的経路を使わないのであれば、iptablesだけでルータとして設定できます。

Linuxをルータとして使うには、異なるネットワーク間でのパケット転送を許可する必要があります。そのためには、IPv4の場合は **/proc/sys/net/ipv4/ip_forward** が、IPv6の場合は **/proc/sys/net/ipv6/conf/all/forwarding** が1になっていなければなりません。0であれば、次のようにして1を書き込みます。

```
echo 1 > /proc/sys/net/ipv4/ip_forward
echo 1 > /proc/sys/net/ipv6/conf/all/forwarding
```

ただし、システムを再起動すると変更内容は失われます。恒久的に設定するには、**/etc/sysctl.conf**ファイルに適切なエントリを記述したり、Red Hat系ディストリビューションの場合は **/etc/sysconfig/network** ファイルに「FORWARD_IPv4=yes」「IPV6FORWARDING=yes」と記述したりしてください（ディストリビューションにより異なります）。

**ここが重要**

● パケット転送の許可に必要なカーネルパラメータを理解しておいてください。
## 14.2.2 IPマスカレード


ゲートウェイとして動作するホストの設定を考えてみましょう。eth0は内部ネットワーク（プライベートIPアドレス）側であり、eth1にはWAN側のグローバルIPアドレスが割り当てられているものとします。LAN 内のホストがインターネットを利用する際、送信元IPアドレスをプライベートアドレスからグローバルアドレスに変換してWAN 側に送り出したり、その逆を行ったりする機能を**IPマスカレード**といいます。IPマスカレードを使ってアドレス変換を行うには、次のようにします。

```
# iptables -t nat -A POSTROUTING -o eth1 -j MASQUERADE
```

WAN側IPアドレスが固定されている場合は、MASQUERADEではなくSNAT が推奨されています。WAN側IPアドレスが10.1.2.3、内部ネットワークのIPアドレスが192.168.0.0/24の場合、このゲートウェイを通過してインターネットに出て行くパケットは、送信元IPアドレスが10.1.2.3に書き換えられます。

```
# iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth1 -j SMAT 10.1.2.3
```


# 14.3 FTP サーバのセキュリティ


**FTPサーバ**には、古くからUNIX系OSで利用されている**wu-ftpd**、設定が容易な**ProFTPD**、高い安全性を誇る**vsftpd**、セキュリティと実用性を重視した**Pure-FTPD**などがあります。
## 14.3.1 ProFTPD の設定

ProFTPD【注3】の設定は、**proftpd.conf**で行います。proftpd.confはhttpd.confの書式と似ているので、Apacheの設定に馴染みがあれば比較的簡単に設定ができます。

▶ **proftpd.confの設定例**

```
# アクセス時に表示されるサーバ名
ServerName "ProFTPD Server"
# standalone（デーモン）か inetd（スーパーサーバー/経由）かを指定
ServerType standalone
ServerIdent No         # バージョン表示を無効
RootLogin Off          # rootログインを禁止
DefaultRoot ~          # ホームディレクトリ以下だけアクセスを許可
AuthPAMAuthoritative on  # PAMの認証を有効に

TimeoutIdle 120        # タイムアウトするまでの待ち時間
Port 21                # ポート番号
Umask 022              # デフォルトのUMASK値
MaxClientsPerHost 10   # 1ホストにつき接続数10のクライアントを許可
MaxInstances 30        # 最大インスタンス数
User nobody            # デフォルトのユーザー名
Group nobody           # デフォルトのグループ名

<Global>
  AllowOverwrite yes  # ファイルを上書きすることを許可する
  <Limit ALL SITE_CHMOD>
    AllowAll         # すべてのFTPコマンドにアクセスを許可する
  </Limit>
</Global>

# 読み取りのみは許可、書き込みは禁止
<Limit READ>
  AllowAll
</Limit>
<Limit STOR>
  DenyAll
</Limit>

# 全IPアドレスからのログインを許可
<Limit LOGIN>
  Order Deny,Allow
  Allow from all
</Limit>

# 匿名ログインを許可しない場合に100ユーザーまで（および超過した場合のメッセージ）
MaxClients 100 "Sorry, max %m users -- try again later"

# ファイル転送ログ
TransferLog /var/log/proftpd/xferlog.legacy
```

アクセス制御の設定は、Limitディレクティブで行います。

_書式：_ `　<Limit FTP コマンドもしくはFTP コマンドグループ> ～ </Limit>`

Limitディレクティブ内に記述できるアクセス制御ディレクティブとFTPコマンド、FTPコマンドグループは次のとおりです。

表14-3　アクセス制御ディレクティブ

|ディレクティブ|説明|
|---|---|
|Order allow,deny\|deny,allow|AllowとDenyがチェックされる順序|
|Allow from 場所|許可するホストやネットワークを指定|
|AllowAll|許可を明示|
|AllowUser|許可するユーザー|
|AllowGroup|許可するグループ|
|Deny from 場所|拒否するホストやネットワークを指定|
|DenyAll|拒否を明示|
|DenyUser|拒否するユーザー|
|DenyGroup|拒否するグループ|

表14-4　FTPコマンド

|オプション|説明|
|---|---|
|RETR|サーバからクライアントへのファイル転送|
|STOR|クライアントからサーバへのファイル転送|
|REN|ファイル名変更|
|DELE|ファイル削除|
|RMD|ディレクトリ削除|
|SITE_CHMOD|パーミッション変更|

表14-5　FTPコマンドグループ

| オプション | 説明                |
| ----- | ----------------- |
| DIRS  | ファイル名一覧の取得        |
| READ  | ファイルの読み込み         |
| WRITE | ファイル、ディレクトリの作成・削除 |
| ALL   | すべてのFTPコマンド       |
| LOGIN | ログイン【注4】          |

## 14.3.2 vsftpd の設定

vsftpd【注5】は、設定の容易さと安全性【注6】を兼ね備えたFTPサーバです。設定は**vsftpd.conf**ファイルで行います。

_書式：_ `設定項目名=設定値`

▶ **vsftpd.confの設定例**

```
# ローカルユーザーのログインを許可
local_enable=YES

# 書き込みを許可
write_enable=YES

# umask値を022とする
local_umask=022

# 20番ポートからの送信接続
connect_from_port_20=YES

# ファイル転送ログを残す
xferlog_enable=YES

# ファイル転送ログファイル
xferlog_file=/var/log/vsftpd.log

# ログファイルの形式（YESならwu-ftpdと同様の形式だが見づらい）
xferlog_std_format=NO
```

## 14.3.3 FTP サーバのアクセス制御

FTPログインを許可しないユーザーを指定するには、**/etc/ftpusers**【注7】にユーザーのリストを記述します。rootユーザーやシステムアカウントを記述しておくとよいでしょう。

▶ **/etc/ftpusers**

```
root
bin
daemon
lp
mail
(中略)
baduser1
baduser2
```

FTPログインを許可しても、すべてのディレクトリに移動できるようではセキュリ ティ上問題です。chroot 機能を使うと、特定ディレクトリ以外のディレクトリへ移動 することを禁止できます。ProFTPDの場合は次のように設定することで、ユーザー のホームディレクトリ以下しか移動できないように設定できます。

▶ **proftpd.confの設定例**

```
DefaultRoot ~
```

vsftpdの場合は、次のように設定することで、同様の設定ができます。

▶ **vsftpd.confの設定例**

```
chroot_local_user=YES
```

一部のユーザーだけをchrootしたい場合は、次の設定を記述し、chrootの対象となるユーザーをvsftpd.chroot_listファイルに記述します。

▶ **vsftpd.confの設定例（特定ユーザーのみのchroot）**

```
chroot_list_enable=YES
chroot_list_file=/etc/vsftpd.chroot_list
```

## 14.3.4 Pure-FTPD の設定


Pure-FTPD【注8】は、セキュリティと実用性を重視したFTPサーバです。設定はpure-ftpd.confで行います【注9】。

▶ **pure-ftpd.confの設定例（一部）**

```
# 全ユーザーに対しchrootを適用する
ChrootEveryone         yes

# 最大クライアント数
MaxClientsNumber       50

# IPアドレスあたりの最大クライアント数
MaxClientsPerIP        8

# yesならデーモンとして動作、xinetd経由ならno
Daemonize              yes

# ドットファイルを表示するか
DisplayDotFiles        yes

# PureDBを利用する
PureDB                 /etc/pure-ftpd/pureftpd.pdb

# PAM認証を利用するかどうか
PAMAuthentication      no
```

Pure-FTPDでは、設定ファイルを使わず、起動時にオプションを使って動作を指定することもできます。代表的なオプションを表14-6にまとめます。

表14-6　pure-ftpdの主なオプション

|オプション|説明|
|---|---|
|-4|IPv4のみ利用する|
|-A|全ユーザーに対しchrootを適用する|
|-B|デーモンとして動作する|
|-c 数|最大クライアント数|
|-C 数|IPアドレスあたりの最大クライアント数|
|-e|匿名ユーザーのみログインを許可する|
|-E|匿名ユーザーは利用不可|
|-i|匿名ユーザーにファイルのアップロードを禁止|

## 14.3.5 パッシブモード

FTPは、データ転送に20番ポート、制御に21番ポートと、サーバ側で2つのポートを使用します。クライアントがサーバを利用する場合、一般的にはクライアント側からサーバ側へ接続を要求します。しかし、FTPのデータ転送については、サーバ側からクライアント側へ接続を要求します（アクティブモード）。そのため、クライアントがファイヤウォールの内側にあれば、サーバ側からクライアント側に接続できず、FTP通信ができないことがあります。

![[00730.jpeg]]
図14-3 FTP 接続

この場合は、FTPサーバを**パッシブモード**で動作させることによって回避できます。パッシブモードでは、データ転送もクライアント側からサーバ側へ接続を要求します。パッシブモードで動作させるには、ProFTPDでは次のように設定します。

▶ **proftpd.confの設定例**

```
# ルータのWAN側IPアドレスもしくはドメイン名
MasqueradeAddress     10.2.3.4

# 利用するポート番号の範囲
PassivePorts          52000 52020
```

vsftpdでは、次のように設定します。

▶ **vsftpd.confの設定例**

```
pasv_enable=YES
```

Pure-FTPDでは、次のように設定します。

▶ **pure-ftpd.confの設定例**

```
PassivePortRange        30000 50000
```

## 14.3.6 匿名FTP サーバ

wu-ftpdで**匿名**（anonymous）**FTP**サービスを利用できるようにする場合、chroot を使って、権限のないディレクトリへアクセスできないようにすることでセキュリティを高めます。一般的には、/home/ftpなどのディレクトリを作成し、その中にbin、lib、etcディレクトリを作成し、FTPサービスに必要なファイルをコピーします【注10】。また、anonymousユーザー用のディレクトリ（/home/ftp/pubなど）も作成します。そして、/home/ftpにchrootすることで、他のディレクトリツリーへはいっさいアクセスができなくなります。ディストリビューションによっては、匿名FTP用のパッケージが用意されている場合もあります。
ProFTPDの場合は、proftpd.conf内のAnonymousディレクティブで設定できます。

▶ **proftpd.conf**

```
<Anonymous ~ftp>
User    ftp
Group   ftp

# ダウンロードは許可、アップロードは拒否
<Limit READ>
  AllowAll
</Limit>
<Limit STOR>
  DenyAll
</Limit>
</Anonymous>
```

vsftpdの場合は、vsftpd.conf内で設定できます。

▶ **vsftpd.conf**
```
anonymous_enable=YES       # 匿名FTPを許可
anon_upload_enable=NO      # 匿名ユーザーによるアップロードを禁止
anon_mkdir_write_enable=NO # 匿名ユーザーによるディレクトリ作成を禁止
```


# 14.4 OpenSSH


**SSH**（Secure Shell）は、リモートホスト間の通信において高いセキュリティを実現するものです。強力な認証機能と暗号化により、ファイル転送やリモート操作を安全に行うことができます。たとえばtelnetを使った場合、通信内容は平文なので、通信経路を盗聴されると容易にアカウントやパスワードが判明してしまいます。SSHでは経路を流れるデータが暗号化されるため、より安全性は高まります。Linuxでは、OpenBSDグループによるSSHの実装である**OpenSSH**が一般的に利用されています。SSHには現在、バージョン1 系とバージョン2 系があり、公開鍵暗号方式の認証アルゴリズムに違いがあります（それ以外にも多くの相違点があります）。バージョン1 系ではRSAが、バージョン2 系ではDSA、ECDSA、ED25519、RSA が公開鍵認証に使われています。それぞれのプロトコルは互換性がありませんが、OpenSSHでは両方のプロトコルに対応しています。

## 14.4.1 SSHの設定

SSHサーバの機能は**sshd**デーモンにより提供されます。sshdの設定ファイルは、**/etc/ssh/sshd_config**です。

表14-7　/etc/ssh/sshd_configファイルの主な設定項目

| 設定項目                   | 説明                        |
| ---------------------- | ------------------------- |
| Port                   | SSHで使うポート番号（デフォルトは22）     |
| Protocol               | 利用するSSHのバージョン             |
| ListenAddress          | 接続受付アドレス（0.0.0.0であればすべて）  |
| HostKey                | ホスト鍵ファイルのパス               |
| SyslogFacility         | ログのファシリティ                 |
| LogLevel               | ログのプライオリティ                |
| LoginGraceTime         | ログインを試みることのできる最大時間（秒）     |
| PermitRootLogin        | rootログインの許可/ 禁止           |
| StrictModes            | パーミッションを厳密にチェックするかどうか     |
| MaxAuthTries           | 認証を試みることのできる最大回数          |
| RSAAuthentication      | SSH1での公開鍵認証を許可するかどうか      |
| PubkeyAuthentication   | SSH2での公開鍵認証を許可するかどうか      |
| AuthorizedKeysFile     | 公開鍵を登録するファイル              |
| PasswordAuthentication | パスワード認証の有効/ 無効            |
| PermitEmptyPasswords   | 空パスワードの有効/無効              |
| UsePAM                 | PAMを使用する                  |
| X11Forwarding          | X11フォワーディングの有効/無効         |
| AllowUsers             | ログインを許可するユーザー             |
| DenyUsers              | ログインを禁止するユーザー             |
| AllowGroups            | ログインを許可するグループ             |
| DenyGroups             | ログインを禁止するグループ             |
| Subsystem              | 外部サブシステムを指定（ファイル転送デーモンなど） |

次に示すのは/etc/ssh/sshd_configの設定例です。

▶ **/etc/ssh/sshd_configファイルの設定例**

```
Port 22
Protocol 2
ListenAddress 0.0.0.0

HostKey /etc/ssh/ssh_host_key
HostKey /etc/ssh/ssh_host_rsa_key
HostKey /etc/ssh/ssh_host_dsa_key

SyslogFacility AUTHPRIV
LogLevel INFO

LoginGraceTime 2m
PermitRootLogin no
StrictModes yes
MaxAuthTries 6

RSAAuthentication yes
PubkeyAuthentication yes
AuthorizedKeysFile .ssh/authorized_keys

PasswordAuthentication no
PermitEmptyPasswords no

UsePAM yes
X11Forwarding yes

# SFTPを使う場合は以下を設定
Subsystem sftp /usr/libexec/openssh/sftp-server

```

## 14.4.2 ホスト認証とユーザー認証

SSHでは、ユーザー認証に先立って、ホストの正当性を確認する**ホスト認証**（ホスト間認証）が行われます。
### ホスト認証

ホスト認証は、接続先ホスト（SSHサーバ）の正当性を確認する認証です。もし、DNSサーバのクラックなどにより、不正なホストに接続させられてしまった場合は、気づかずにいるとパスワードなどの情報を奪取されてしまう危険があります。そのため、SSHでは、**公開鍵暗号方式**を用いてホストの正当性を確認します。

公開鍵暗号方式では、公開鍵と秘密鍵のペアを使って認証を行います。OpenSSHをインストールすると、ローカルホスト用の公開鍵と秘密鍵が作成されます。秘密鍵は外部に漏れないように管理します【注11】。ファイルは/etc/sshディレクトリ以下に配置されます。

表14-8　ホストの公開鍵と秘密鍵

| ファイル名                    | 説明                    |
| ------------------------ | --------------------- |
| ssh_host_key             | 秘密鍵（バージョン1 用）         |
| ssh_host_dsa_key         | 秘密鍵（バージョン2、DSA用）      |
| ssh_host_rsa_key         | 秘密鍵（バージョン2、RSA 用）     |
| ssh_host_key.pub         | 公開鍵（バージョン1 用）         |
| ssh_host_dsa_key.pub     | 公開鍵（バージョン2、DSA 用）     |
| ssh_host_rsa_key.pub     | 公開鍵（バージョン2、RSA 用）     |
| ssh_host_ecdsa_key       | 秘密鍵（バージョン2、ECDSA 用）   |
| ssh_host_ecdsa_key.pub   | 公開鍵（バージョン2、ECDSA用）    |
| ssh_host_ed25519_key     | 秘密鍵（バージョン2、ED25519 用） |
| ssh_host_ed25519_key.pub | 公開鍵（バージョン2、ED25519 用） |

ホストの公開鍵と秘密鍵は、ホストごとにユニークなものです。SSHでの接続ごとに、ホストの公開鍵（ホスト鍵）がクライアントへ送信されます。クライアントは所持しているホスト鍵と一致するかどうか確認することで、ホストの正当性を確認できます。ホスト鍵は、**~/.ssh/known_hosts** に格納されます。初回接続時には、̃/.ssh/known_hostsにはホスト鍵が登録されていないため、次のようなメッセージが表示されます。

```
The authenticity of host 'lpic2.example.net (192.168.132.136)' can't be established.
RSA key fingerprint is 1f:64:03:0b:49:fe:de:15:f6:6d:2c:c2:06:dc:bc:0b.
Are you sure you want to continue connecting (yes/no)?
```

ここで「yes」と入力すると、̃/.ssh/known_hostsにホスト鍵が登録されます。あらかじめサーバ管理者より鍵のフィンガープリント【注12】を入手しておけば、本物であるかどうかを確認できます。サーバ側で鍵のフィンガープリントを確認するには、次のようにします。

```
# ssh-keygen -l -f /etc/ssh/ssh_host_rsa_key.pub
2048 1f:64:03:0b:49:fe:de:15:f6:6d:2c:c2:06:dc:bc:0b /etc/ssh/ssh_host_rsa_key.pub
```

次回以降は、接続先ホストから送られてきたホスト鍵をknown_hosts内の鍵と比較し、問題がなければユーザー認証に進みます。もしも接続先ホストが悪意のある何者かによってなりすまされていたら、次のようなメッセージが表示されるため、誤ってパスワードを入力したりログインしたりしてしまうことを防げます。

```
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that the RSA host key has just been changed.
The fingerprint for the RSA key sent by the remote host is
7e:16:86:03:13:2a:7f:85:28:70:27:eb:5b:03:94:70.
Please contact your system administrator.
Add correct host key in /home/student/.ssh/known_hosts to get rid of this message.
Offending key in /home/student/.ssh/known_hosts:2
RSA host key for lpic2.example.net has changed and you have requested strict checking.
Host key verification failed.
```

以下は、known_hostsファイルの内容例です。

```
$ cat known_hosts
sv1,192.168.120.71 ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAIEA0FgpRDNsXhz/w1JksSDVtKJsAa
An7JFX7I+JFI+SFe1PQL05dvte9AUNdCNF/9j9j8D1JAhvFRoNshaUrh0kO1ltyQgu7ja1k43+ucMF
n7YqLT9E1fTav9Cdj8M34bYX06ou1XxTXy/g+oCf8EU8NZnT19YFeAvpb8+BYB5tvcOU=
```

## 14.4.3 公開鍵認証

ホスト認証を終えると、次にユーザー認証に進みます。ユーザー認証はまず**公開鍵認証**が試されます。公開鍵認証は、公開鍵暗号方式を使ってユーザーの本人確認を行う方法です。公開鍵暗号方式では、一組の公開鍵と秘密鍵を使います。片方の鍵で暗号化したデータは、ペアとなる鍵でのみ復号できます。この性質を認証に利用するわけです。公開鍵認証のおおまかな手順は次のとおりです【注13】。

1. あらかじめサーバ側に公開鍵を登録しておく
2. SSH接続時に公開鍵が利用できるかどうかの確認が行われる
3. クライアント側は公開鍵にユーザー名等のデータを加え、秘密鍵で署名してサーバ側に送信される
4. サーバ側ではユーザーの公開鍵を使って署名を確認する
5. 確認できればログインを許可する

ユーザーの公開鍵と秘密鍵のペアを作成するには、**ssh-keygenコマンド**を使います。

_書式：_ `ssh-keygen [オプション]`

表14-9　ssh-keygenコマンドの主なオプション

| オプション     | 説明                                                                                                                                                                    |
| --------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| -f ファイル名  | 鍵ファイル名を指定する                                                                                                                                                           |
| -t        | 暗号化方式を指定する  <br>　-t rsa1：SSHバージョン1のRSA鍵  <br>　-t dsa：SSHバージョン2のDSA鍵  <br>　-t rsa：SSHバージョン2のRSA鍵  <br>　-t ecdsa：SSHバージョン2のECDSA 鍵  <br>　-t ed25519：SSHバージョン2のED25519 鍵 |
| -p        | 既存の鍵ファイルのパスフレーズを変更する                                                                                                                                                  |
| -P パスフレーズ | 古いパスフレーズを指定する                                                                                                                                                         |
| -N パスフレーズ | 新しいパスフレーズを指定する                                                                                                                                                        |
| -l        | フィンガープリントを表示する                                                                                                                                                        |
| -R ホスト名   | 指定されたホストの鍵をknown_hostsファイルから削除する                                                                                                                                      |

作成される鍵ファイルのデフォルトの名前は次のとおりです。

表14-10　公開鍵と秘密鍵のファイル名

| バージョン           | 秘密鍵        | 公開鍵            |
| --------------- | ---------- | -------------- |
| バージョン1          | identity   | identity.pub   |
| バージョン2（DSA）     | id_dsa     | id_dsa.pub     |
| バージョン2（RSA）     | id_rsa     | id_rsa.pub     |
| バージョン2（ECDSA）   | id_ecdsa   | id_ecdsa.pub   |
| バージョン2（ED25519） | id_ed25519 | id_ed25519.pub |

次の例では、RSAアルゴリズムの鍵ペアを作成しています。パスフレーズには空白も含めることができ、パスワードよりも長い文字列を指定することができます【注14】。

```
$ ssh-keygen -t rsa
Generating public/private rsa key pair.
Enter file in which to save the key (/home/student/.ssh/id_rsa): (Enterキーを入力)
Enter passphrase (empty for no passphrase): (パスフレーズを入力)
Enter same passphrase again: (パスフレーズを再入力)
Your identification has been saved in /home/student/.ssh/id_rsa.
Your public key has been saved in /home/student/.ssh/id_rsa.pub.
The key fingerprint is:
0e:43:95:c1:aa:e7:79:33:84:15:e2:7a:b1:75:7c:3c student@lpic2.example.net
The key's randomart image is:
+--[ RSA 2048]----+
|    .o            |
|    .o            |
|    o . .         |
|   + o o          |
|  oBS.            |
| o O+++ E         |
| o..=o.+ .        |
|   ..=o + .       |
|   .   . o.       |
+------------------+
```

秘密鍵の内容例は次のとおりです。

```
$ cat .ssh/id_rsa
-----BEGIN RSA PRIVATE KEY-----
Proc-Type: 4,ENCRYPTED
DEK-Info: AES-128-CBC,466E7E1ABAC0116FD64E967F4FB64124

Ue9eGNI9UTIN7X61jBqnFfyesfuhS4MRYiG9uFUveAQSd9/yhZv0CKAe+Aev7ZP
DvbA2ShPOzF8ibv0xRMGIb12yUEUj76m/BGdhuZxWNh9oTPr5YuOiaYgy7Sj
/j+bSdhkK3gFGw6aDhMNVvU13uKjw49Gt3jztCq1A//TaytkynOgTfyIeNCn
31QHeRQqyk8u9Z9jaFSUl84BDpTDnpr92+i9ufXA8M5/Bm4f+1pbm/3gfC6d201

(省略)

Fv4ZyUregBiRT6XJRBh2X1ZoEzWLug1JMg9zREdva4L/JT84EweMKEOxTjUKHeb+
AvjE2orSbvh2S+ASwoiezRgyBZbaeav435Y0Bx9m0llNwbHps3Th24JqMK7Jer
-----END RSA PRIVATE KEY-----
```

公開鍵の内容例は次のとおりです。

```
$ cat .ssh/id_rsa.pub
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCqa7u2Qni7pBO6YtMaJPWf6sryiomdGt
lmYgX2sF57QkBhnDZs0opCuWvXJYBrjBXbtZSZEBxJ9rLqYClESLzKtwPSP7JJ7zBxp
QPh2vWpWvY0Ssfz7KkDlog3VHOEXf7XEJl+We7wp2vx3oJEm315up4mZj/nMGL6gJ0Q
f/YS6hidxgE3pB0MUtgLC7448BFqcT/tZgqhyL7qMKC5kg4U4k4n7/s/OnEaft6GAe
BSZj5Glo4vPFMvwiqL7J7ZASSfE+9nmhLCbaJjLJKBxjPZpmhnNVGJrzeLNQabxn0ti
8XpqNRnk5xVTr/sAYr/jFwZP student@lpic2.example.net
```

次に、ユーザーの公開鍵ファイルを接続先ホストの **~/.ssh/authorized_keys** ファイルに登録します。鍵ファイルはあらかじめscpコマンドなどで転送しておきます。以下の例では、RSA公開鍵を登録しています。

```
$ cat id_rsa.pub >> ~/.ssh/authorized_keys
```

authorized_keysファイルは、所有者のみ読み書きできるようにしておきます【注15】。

```
$ chmod 600 ~/.ssh/authorized_keys
```

SSHで接続してみます。

```
$ ssh server.example.net
Enter passphrase for key '/home/student/.ssh/id_rsa'
```

パスフレーズを尋ねられれば、公開鍵認証が有効になっています。

**参考**
ssh-copy-idコマンドを使うと、簡単に公開鍵を接続先ホストに登録できます。

**ここが重要**
● ホスト用の鍵ファイル名、ユーザー用の鍵ファイル名、鍵の作成方法、鍵の登録手順を理解しておきましょう。


## 14.4.4 ssh-agent


秘密鍵ファイルを使用する際は、パスフレーズを尋ねられます。パスフレーズを入力する手間を省くには、**ssh-agent**を利用します。ssh-agentはクライアント側で稼働するデーモンであり、秘密鍵をメモリ上に保持しておき、必要となった時点でそれを利用するため、その都度パスフレーズを入力する必要がありません。ssh-agent を利用するには、ssh-agentの子プロセスとしてbashシェルを起動します。

```
$ ssh-agent bash
```

次に、**ssh-add**コマンドを使って秘密鍵を登録します。このときに、パスフレーズを入力します。

```
$ ssh-add
Enter passphrase for /home/student/.ssh/id_rsa:
Identity added: /home/student/.ssh/id_rsa (/home/student/.ssh/id_rsa)
```

以後、このbashシェルならびにその子プロセスでは、パスフレーズの入力が不要になります。ssh-agentが保持している秘密鍵の一覧は、**ssh-add　-lコマンド**で確認できます。

```
$ ssh-add -l
2048 0e:43:95:c1:aa:e7:79:33:84:15:2e:7a:b1:76:7c:3c /home/student/.ssh/id_rsa (RSA)
```

  

**コラム**
**パスフレーズなしの鍵の利用**
特定のコマンドをcronなどで定期的に実行するために、パスフレーズなしの鍵を作成することがあります。ssh-keygenコマンドで鍵ペアを作成する際にパスフレーズを入力しなければ、秘密鍵をパスフレーズなしで利用できます。ただし、秘密鍵を奪われると即座に悪用される恐れがあるため、セキュリティ上好ましくはありません。authorized_keysファイルに「command="コマンド"」と書いておくと、当該の公開鍵を使ったときに、指定したコマンドだけを実行可能とすることができます。

## 14.4.5 SSHポート転送


**SSHポート転送**とは、あるポートに送られてきたTCPパケットを、SSHを使った安全な通信路を経由して、リモートホストの任意のポートに転送することです。この機能を使うと、POPやFTPなど、暗号化されていないプロトコルを使った通信の安全性を高めることができます。
![[00751.jpeg]]
図14-4　ポート転送

ポート転送を行う際のsshの書式は次のとおりです。

_書式：_ `ssh -L [ローカルポート]:[リモートホスト]:[リモートポート] [リモートホストのユーザー名]@[リモートホスト]`

次の例では、ローカルホストの10110番ポートに接続すると、リモートホストpop.example.netの110番ポートに接続できます。

```
$ ssh -L 10110:pop.example.net:110 student@pop.example.net
```

上記のsshコマンドを実行した後、メーラのPOPサーバの設定を変更し、localhost の10110番ポートへ接続するようにします。

## 14.4.6 SSH サーバのセキュリティ
SSHサーバをデフォルトの設定で運用するのではなく、適切な設定を施すことで、よりセキュアな運用が可能になります。

### SSH バージョン1 の禁止

SSHのバージョン1は安全性が確保できないので、SSHバージョン2のみ許可するようにします。

▶ **/etc/ssh/sshd_config（一部）**

```
Protocol 2
```

### パスワード認証の禁止

パスワード認証は原則として禁止すべきです。パスワードを知られるとなりすましによるログインを許してしまうことになりますし、ブルートフォース攻撃によってパスワードを破られる可能性もあります。パスワード認証を禁止するには、次のようにします。

▶ **sshd_config**

```
PasswordAuthentication no
```

### rootログインの禁止

rootユーザーのログインも許可すべきではありません。デフォルトでは許可されているので、次のように変更してrootログインを禁止します。

▶ **sshd_config**

```
PermitRootLog no
```

### ログインユーザーの制限

ユーザー単位でログインを制限することもできます。AllowUsersディレクティブを使ってユーザーを指定すると、指定しなかったユーザーはすべてログイン禁止になります。また、DenyUsersディレクティブの場合は、指定したユーザーのみログイン禁止になります。同様の設定項目として、AllowGroups、DenyGroupsもあります。設定例を表14-11にまとめます。

表14-11　AllowUsers、AllowGroups 等の記述例


| 書式                            | 説明                        |
| ----------------------------- | ------------------------- |
| AllowUsers fred               | fredユーザーのみ許可              |
| AllowUsers fred john          | fredおよびjohnユーザーのみ許可       |
| AllowUsers `fred@172.16.0.1`  | 172.16.0.1のfredユーザーのみ許可   |
| AllowUsers `fred@example.net` | example.netのfredユーザーのみ許可  |
| AllowUsers `*@172.16.0.1`     | ホストが172.16.0.1のユーザーのみ許可   |
| AllowGroups wheel admin       | グループがwheelとadminのユーザーのみ許可 |
### 接続元の制限

SSHへのアクセスは、/etc/hosts.allow、/etc/hosts.denyで制限できます。これは、sshdが通常libwrapを使ってTCP Wrapper機能（「14.5.3　TCP Wrapper」を参照）を利用しているからです。libwrapを利用しているかどうかは、次のようにして確認できます。

```
$ ldd `which sshd` | grep libwrap
	libwrap.so.0 => /usr/lib/libwrap.so.0 (0x0043000c)
```

このようにlibwrapが表示されれば、そのsshdは/etc/hosts.allow、/etc/hosts.denyによってアクセス制御を設定できます。たとえば、172.16.0.100からのアクセスのみ許可する場合は、次のように設定します。

▶ **/etc/hosts.allow**

```
sshd: 172.16.0.100
```

▶ **/etc/hosts.deny**

```
sshd: ALL
```


# 14.5 セキュリティ業務

Linuxに備わっているさまざまなコマンドやツールを適切に使って、セキュリティを高めることができます。逆に、設定やコマンドをよく知らないまま使っていると、思わぬセキュリティホールになってしまうこともあります。システムについて十分理解するとともに、便利なオープンソースソフトウェアを利用してセキュリティを高めることも必要です。
## 14.5.1 セキュリティツール
ここでは、Linuxで利用できる、オープンソースのセキュリティツールをいくつか紹介します。
### Snort
**Snort**【注16】は、ネットワークインターフェース上のトラフィックを監視し、パケットをさまざまな規則と照合することで、攻撃や侵入を捕えることができる、パケットスニファリングツールです。Snortが参照する規則（ルールセット）は自分で作成することもできますが、ユーザーコミュニティが作成した多数のルールセットがインターネットから入手できます【注17】。新手の攻撃に備えるため、ルールセットは環境に合わせて最新の状態に保っておく必要があります。Snortを利用するには、パケットキャプチャライブラリであるlibpcapが必要です。
### Tripwire
**Tripwire**【注18】は、ファイルシステムの状況をあらかじめ記録しておいて比較することで、ファイルの改ざんを検知するプログラムです。リアルタイムで改ざんを検知するわけではなく、cronによるスケジューリングに従って起動します。Tripwireのインストール〜設定には、次のような手順が必要です。
- パッケージもしくはソースからのインストール
- ポリシーファイル（監査対象についての設定）の作成
- ベースラインデータベースの作成（基準となるファイル情報）
- 定期的なチェック（現状とベースラインデータベースとの比較）
- 必要に応じてデータベースおよびポリシーファイルのアップデート

Tripwireを使ってチェックできる主な項目は次のとおりです。
- ファイルタイプ
- パーミッション
- 所有ユーザー
- 所有グループ
- アクセス時刻
- ファイルの更新日時
- ブロック数
- ファイルサイズ
- リンク数
- iノード番号
- iノードのタイムスタンプ
- iノードのあるデバイスID
- MD5ハッシュ値
- SHAハッシュ値
- Havalハッシュ値
- CRC32ハッシュ値
### OpenVAS
**OpenVAS**【注19】は、オープンソースのセキュリティスキャナで、ネットワーク経由で脆弱性のチェックができるツールです【注20】。OpenVASは表14-12のコンポーネントから構成されます。

表14-12　OpenVASのコンポーネント

| コンポーネント                     | 説明                        |
| --------------------------- | ------------------------- |
| OpenVAS Scanner             | セキュリティスキャナ                |
| OpenVAS Manager             | スキャナとスキャンタスク、データの管理ソフトウェア |
| OpenVAS Administrator       | サービスやユーザーを管理するソフトウェア      |
| Greebone Security Assistant | Webブラウザベースで操作するインターフェース   |
| Greenbone Security Desktop  | GUIベースのクライアント             |
| OpenVAS CLI                 | コマンドラインベースのクライアント         |

### Fail2ban
Fail2ban【注21】は、ログファイルを監視して攻撃を検知し、攻撃元のIPアドレスを遮断するソフトウェアです。具体的には、一定時間内に何度もログインを失敗するといったイベントが起こると、iptablesのルールを書き換え、アクセス元からの接続を遮断します。たとえば、デフォルトではSSHでの認証が5回失敗すると、そのIPアドレスをブロックします。iptablesで見てみると、Fail2ban用のルールが追加されているのがわかります。

```
# iptables -L INPUT
Chain INPUT (policy ACCEPT)
target     prot opt source               destination
fail2ban-SSH  tcp  --  anywhere             anywhere             tcp dpt:ssh
```

Fail2banは、SSHによるアクセスについて、/var/log/secureを監視し、設定されたアクションを検知するとアクセスを遮断します。次の例では、192.168.11.15からのアクセスがブロックされています。

```
# fail2ban-client status ssh-iptables
Status for the jail: ssh-iptables
|- filter
|  |- File list:        /var/log/secure
|  |- Currently failed: 1
|  `- Total failed:     12
`- action
   |- Currently banned: 1
   |  `- IP list:       192.168.11.15
   `- Total banned:     1
```

## 14.5.2 開いているポートの表示


**nmap**【注22】は、ポートスキャンを実施して、開かれているポートから稼働しているサービスを推定することができるツールです。ポートスキャンは攻撃の準備としても使われるため、自分の管理するホスト以外を検査しないよう注意が必要です。

_書式：_ ` nmap [オプション] 対象ホスト`

表14-13　nmapコマンドの主なオプション


| オプション | 説明               |
| ----- | ---------------- |
| -sT   | TCPスキャンを実施する     |
| -sU   | UDPスキャンを実施する     |
| -sS   | TCP SYNスキャンを実施する |
| -sF   | TCP FINスキャンを実施する |
| -sN   | NULLスキャンを実施する    |
| -sX   | Xmasツリースキャンを実施する |
| -sR   | RPCスキャンを実施する     |
| -O    | OSを推定する          |

以下はホストwww.example.netに対してnmapを実行した結果です。開いているポート番号とサービス名が確認できます。

```
# nmap www.example.net

Starting Nmap 4.11 ( http://www.insecure.org/nmap/ ) at 2012-07-29 01:59 JST
Interesting ports on www.example.net (192.168.115.128):
Not shown: 1677 closed ports
PORT    STATE SERVICE
22/tcp  open  ssh
80/tcp  open  http
443/tcp open  https

Nmap finished: 1 IP address (1 host up) scanned in 0.148 seconds
```

nmapでは、さまざまな形態のポートスキャンを実施することができます。次の例では、**Xmasツリースキャン**を実施しています。Xmasツリースキャンとは、TCPヘッダのFIN、URG、PSHフラグを有効にしたパケットを送って反応を確かめる手法です。

```
# nmap -sX www.example.net
```

開いているポートは、ホスト上で**netstatコマンド、ssコマンド、lsofコマンド、fuser コマンド**を実行しても確認できます。

```
$ netstat -atun
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address        Foreign Address       State
tcp        0      0 0.0.0.0:22           0.0.0.0:*             LISTEN
tcp        0      0 127.0.0.1:25         0.0.0.0:*             LISTEN
tcp6       0      0 :::22                :::*                  LISTEN
tcp6       0      0 :::25                :::*                  LISTEN
udp        0      0 0.0.0.0:39300        0.0.0.0:*             
udp        0      0 0.0.0.0:68           0.0.0.0:*             
udp6       0      0 :::60532             :::*                 
```

```
$ ss -atun
Netid  State       Recv-Q  Send-Q  Local Address:Port  Peer Address:Port
udp    UNCONN      0       0       *:39300             *:*
udp    UNCONN      0       0       *:68                *:*
udp    UNCONN      0       0       :::60532            :::*
tcp    LISTEN      0       128     *:22                *:*
tcp    LISTEN      0       100     127.0.0.1:25        *:*
tcp    LISTEN      0       128     :::22               :::*
tcp    LISTEN      0       100     :::25               :::*
```

```
# lsof -i -n
COMMAND    PID  USER  FD   TYPE   DEVICE SIZE/OFF NODE NAME
sshd       878  root  3u   IPv4   15681  0t0      TCP *:ssh (LISTEN)
sshd       878  root  4u   IPv6   1569C  0t0      TCP *:ssh (LISTEN)
master     1389 root  13u  IPv4   16902  0t0      TCP 127.0.0.1:smtp (LISTEN)
master     1389 root  14u  IPv6   16903  0t0      TCP [::1]:smtp (LISTEN)
dhclient   3812 root  6u   IPv4   24045  0t0      UDP *:bootpc
dhclient   3812 root  20u  IPv4   24043  0t0      UDP *:39330
dhclient   3812 root  21u  IPv6   24035  0t0      UDP *:60532
```

```
# fuser -v -n tcp 22
                     USER    PID  ACCESS  COMMAND
22/tcp:             root      878  F....   sshd
                    root     3845  F....   sshd
```


表14-14　netstatコマンドの主なオプション

| オプション | 説明                       |
| ----- | ------------------------ |
| -a    | すべてのソケットを表示する            |
| -i    | ネットワークインターフェース情報を表示する    |
| -s    | 統計情報を表示する                |
| -n    | 名前解決を行わない                |
| -l    | 接続待ち（LISTEN）状態のソケットを表示する |
| -t    | TCPソケットを表示する             |
| -u    | UDPソケットを表示する             |
| -r    | ルーティングテーブルを表示する          |

表14-15　ssコマンドの主なオプション

| オプション | 説明                      |
| ----- | ----------------------- |
| -a    | すべてのソケットを表示する           |
| -n    | アドレスやポートを数値で表示する        |
| -p    | PIDとプロセスも表示する（管理者権限が必要） |
| -r    | ホスト名を解決する               |
| -t    | TCPを表示する                |
| -u    | UDPを表示する                |
| -4    | IPv4のみを表示する             |
| -6    | IPv6のみを表示する             |

表14-16　lsofコマンドの主なオプション


| オプション      | 説明                                |
| ---------- | --------------------------------- |
| -c コマンド    | 指定したコマンド名に一致するプロセスのみを表示する         |
| -i[:_ポート_] | 指定したポート番号のIP 通信のみを表示する            |
| -n         | 名前解決を行わない                         |
| -p _PID_   | 指定したPIDのプロセスのみを表示する               |
| -u _UID_   | 指定したユーザーID（もしくはユーザー名）のプロセスのみを表示する |

表14-17　fuserコマンドの主なオプション


| オプション   | 説明                   |
| ------- | -------------------- |
| -n 名前空間 | tcpやudpといった名前空間を指定する |
| -v      | 詳細に表示する              |

**ここが重要**
● ポート番号の確認手段とそれぞれのコマンドの表示内容を理解しておきましょう。

## 14.5.3 TCP Wrapper


**TCP Wrapper**は、各種サーバプログラムへのアクセス制御を集中的に管理する仕組みで、libwrapライブラリによって提供されます。アクセス制御の設定は、**/etc/hosts.allow**および **/etc/hosts.deny** ファイルに記述します。

TCP Wrapperはまず/etc/hosts.allowをチェックします。ファイルに記述された条件にマッチすれば、その時点でアクセスは許可されます。この場合、/etc/hosts.denyファイルは参照されません。/etc/hosts.allowにマッチする条件がなければ、次に/etc/hosts.denyをチェックします。このファイルに記述された条件にマッチすれば、その時点でアクセスは拒否されます。条件にマッチしなかったものはアクセスが許可されます。

これらのファイルには、次のような形式で条件を記述します。

表14-18　/etc/hosts.allowと/etc/hosts.denyで使えるワイルドカード

| ワイルドカード        | 意味                                       |
| -------------- | ---------------------------------------- |
| ALL            | すべてのサービスもしくはホスト                          |
| _A_ EXCEPT _B_ | B以外のA                                    |
| LOCAL          | 「.」を含まないすべてのホスト（つまりローカルネットワークセグメント内のホスト） |
| PARANOID       | ホスト名からDNS 検索したアドレスとサービス要求元アドレスが不一致       |

ローカルネットワークセグメント内からのすべてのsshd へのアクセスを許可する場合は、/etc/hosts.allowに次のように記述します。

▶ **/etc/hosts.allow**

```
sshd: LOCAL
```

lpic.jpドメインからのftpアクセスと、192.168.2.0/24のネットワークからのtelnetアクセスを許可する場合は、/etc/hosts.allowに次のように記述します。ドメイン名の前やIPアドレスの後が「.」になっていることに注意してください。

▶ **/etc/hosts.allow**

```
in.ftpd:  .lpic.jp
in.telnetd: 192.168.2.
```

spawnを使って、特定のコマンドを実行させることもできます。/etc/hosts.deny ファイルに次のように記述することで、loggerコマンドを使ってアクセス拒否の記録を取ることができます。

▶ **/etc/hosts.deny**

```
ALL:ALL:spawn logger -t hosts.deny Connection denied from %c
```


**ここが重要**
● /etc/hosts.allowと/etc/hosts.denyの書式は十分理解しておいてください。
## 14.5.4 セキュリティ情報
システムに何らかの脆弱性が発見されれば、ただちに適切な対応を行う必要があります。そのためには随時最新のセキュリティ情報を収集しなければなりません。セキュリティ情報源としては、次のようなものがあります。

### CERT/CC
CERT/CCはセキュリティの専門家から構成される組織であり、セキュリティ事故情報を収集し、セキュリティに関する技術支援情報を常に発信しています。CERT/CCのWebサイトはこまめにチェックすべきでしょう。日本国内では**JPCERT** が活動を行っています。

**CERT/CC** [https://www.cert.org/](https://www.cert.org/)  
**JPCERT** [https://www.jpcert.or.jp/](https://www.jpcert.or.jp/)

### BUGTRAQ
**BUGTRAQ**は、バグ情報を公開するためのメーリングリストです。利用しているソフトウェアにバグが発見された場合は、すみやかにアップデートする必要があります。そのためにもBUGTRAQでの情報収集は不可欠です。BUGTRAQのメーリングリスト購読は、[http://www.securityfocus.com](http://www.securityfocus.com/)/にあるBUGTRAQの案内をご覧ください（Webサイトでも参照できます）。

### CIAC（Computer Incident Advisory Capability）

**CIAC**は米エネルギー省が運営するサイトで、さまざまなセキュリティインシデントの報告や通知を行っています【注23】。

**参考** 
セキュリティ情報は、各ディストリビュータのWebサイトもチェックするようにしましょう。そのほか、IPA（[https://www.ipa.go.jp/security](https://www.ipa.go.jp/security)/）などからも情報が得られます。

## 14.4.5 セキュリティ侵害への対処


サーバがクラックされた場合、攻撃者によって次のようなことが行われる可能性があります。
- 主なコマンドの改ざん
- ログの改ざんやsyslogの停止
- 悪意のあるソフトウェア（malware）の導入と使用

管理者が侵入に気づかないよう、侵入者によってシステム管理用の主なコマンドが改ざんされてしまうと厄介です。たとえば、不正なファイルだけを表示しないよう改ざんされたlsコマンドでは、不正なファイルを発見することができません。その場合は、**echoコマンド**によってlsコマンドを代替することができます。

```
$ echo *
```

「`*`」はシェルによってマッチするファイル名に展開されるので、カレントディレクトリにあるファイルを一覧できます【注24】。

ファイルを改ざんされたかどうかは、rpmコマンドを使っても調べることができます。

```
# rpm -Va
S.5....T.  c  /etc/sysconfig/authconfig
....L....  c  /etc/pam.d/fingerprint-auth
....L....  c  /etc/pam.d/password-auth
....L....  c  /etc/pam.d/postlogin
....L....  c  /etc/pam.d/smartcard-auth
....L....  c  /etc/pam.d/system-auth
(以下省略)
```

-V（--verify）オプションと-a（--all）オプションを組み合わせることで、インストール時点のファイル状態と現状とを比較し、差があればプロパティとともに表示します。

表14-19　RPM 検証記号

| 記号  | 説明                    |
| --- | --------------------- |
| S   | ファイルサイズが異なる           |
| M   | アクセス権かファイルタイプが変更されている |
| 5   | MD5チェックサムの値が異なる       |
| L   | シンボリックリンクが変更されている     |
| U   | 所有者が変更されている           |
| G   | 所属グループが変更されている        |
| T   | ファイルの更新時刻が異なる         |
| D   | デバイスファイルが変更されている      |
| ?   | 不明                    |
| c   | 設定ファイルを表す             |

# 14.6 OpenVPN9

**VPN**（Virtual Private Network：仮想プライベートネットワーク）は、インターネットなどの公衆ネットワークを介して、あたかも専用回線で接続されているかのように、プライベートなネットワークを構築する技術です。インターネットは不特定多数が利用するため、盗聴や改ざんの危険性がありますが、VPNでは暗号化した経路を用意することで安全な通信ができます。
## 14.6.1 OpenVPN の概要

Linuxでは、VPNを利用するのに**OpenVPN**【注25】を使うのが一般的です。OpenVPNは、IPやTCPなどのレイヤー2/レイヤー3プロトコルをSSL/TLSでカプセル化し、OpenVPNサーバとOpenVPNクライアントとの間を安全に接続します。

OpenVPNでは、**PKI**（Private Key Infrastructure：公開鍵基盤）を利用します。認証局（CA）、OpenVPNサーバ、OpenVPNクライアントそれぞれに必要となるファイルを表14-20にまとめます。

表14-20　OpenVPNに必要なファイル

|サイト|ファイル|
|---|---|
|CA（認証局）|CA 証明書、CA 秘密鍵|
|OpenVPNサーバ|CA 証明書、サーバ証明書、サーバ秘密鍵、DHパラメータ|
|OpenVPNクライアント|CA 証明書、クライアント証明書、クライアント秘密鍵|

**注意**
第10章で取り上げたように、第三者CAを利用せず自己署名証明書を使うこともできます。その場合、CA 秘密鍵はOpenVPNサーバに用意します。

OpenVPNクライアントとOpenVPNサーバを接続する形態には、ルーティング接続とブリッジ接続があります。

### ルーティング接続

仮想トンネルネットワーク経由で異なるネットワークに接続する方法です。ルーティング処理を介して接続するので、OpenVPNクライアントとOpenVPNサーバは別々のネットワークが利用できます。LAN同士を相互に接続するような用途に向いています。大規模なアクセス制御にも対応できます。

### ブリッジ接続

仮想インターフェース経由で接続する方法です。接続先ネットワークと同じネットワークセグメントのIPアドレスをOpenVPNクライアントの仮想インターフェース（TAP インターフェース）に割り当てることで、OpenVPNクライアントは接続先ネットワークに参加できます。ブロードキャストが届くので、SambaやWindowsサーバなどが利用できます。小規模なネットワークや個人で利用するにはブリッジ接続のほうが手軽でしょう。

## 14.6.2 必要なファイルの作成
前掲の表14-20に挙げたファイルを作成します。ファイルの作成には、あらかじめ用意されているスクリプトを使います【注26】。

### パラメータの準備

サーバ証明書やCA証明書を作成するには、いくつかのパラメータを指定する必要がありますが、何度も入力するのは手間がかかります。そこで、varsファイル（/etc/openvpn/vars）を編集して、次のパラメータを任意の値に書き換えます。

▶ **vars（抜粋）**
```
export KEY_COUNTRY="JP"
export KEY_PROVINCE="TOKYO"
export KEY_CITY="Shinjuku"
export KEY_ORG="LPIC"
export KEY_EMAIL="root@centos6.example.com"

```

設定した環境を読み込み、不要なファイルを削除します。
```
# cd /etc/openvpn
# source vars
# ./clean-all
```

### CA 証明書、CA秘密鍵 の作成

認証局用のCA 証明書とCA秘密鍵を作成します。
```
# ./build-ca
```

CA 証明書ファイルca.crtと、CA 秘密鍵ファイルca.keyが作成されます。これらのファイルはCAとなるサーバの/etc/openvpn/keysディレクトリに配置します。また、CA証明書はOpenVPNサーバおよびクライアントの/etc/openvpn/keysディレクトリ以下にも配置します。

### サーバ証明書、サーバ秘密鍵の作成
OpenVPNサーバで利用するサーバ証明書とサーバ秘密鍵を作成します。
```
# ./build-key-server server
```
引数にはホスト名【注27】またはファイル名を指定します。前記の例では、サーバ証明書server.crtとサーバ秘密鍵server.keyが作成されます。これらのファイルはOpenVPNサーバの/etc/openvpn/keysディレクトリに配置します。

### DH パラメータの作成
鍵交換を安全に行うためのDH（Diffie Hellman）パラメータを作成します。
```
# ./build-dh
```
dh1024.pemもしくはdh2048.pemファイルが作成されます。これも/etc/openvpn/keysディレクトリに配置します。
### クライアント証明書、クライアント秘密鍵の作成
OpenVPNクライアント用のクライアント証明書とクライアント秘密鍵を作成します。
```
# ./build-key client
```
引数にはホスト名またはファイル名を指定します。クライアント証明書client.csrとクライアント秘密鍵client.keyが作成されます。クライアントが複数の場合は、引数を変更して実行します。作成されたファイルは、安全な方法でクライアントホストの/etc/openvpn/keysディレクトリへ配置します。

### 起動スクリプトの設定

ブリッジ接続のための起動スクリプトopenvpn-startupとopenvpn-shutdownを編集します。また、/usr/share/doc/openvpn-2.3.14/sample/sample-scripts以下にあるbridge-startおよびbridge-stopファイルをコピーしておきます。本書では詳細は割愛します。
▶ **/etc/openvpn/openvpn-startup**

```
#! /bin/sh
/etc/openvpn/bridge-start
route add -net default gw 192.168.1.1
iptables -I FORWARD -i br0 -j ACCEPT
```

▶ **/etc/openvpn/openvpn-shutdown**
```
#! /bin/sh
/etc/openvpn/bridge-stop
```

## 14.6.3 OpenVPN サーバの設定


ここではブリッジ接続の例を取り上げます。OpenVPNサーバの設定ファイルは、/etc/openvpn/server.confです。CentOS 7の場合、/usr/share/doc/openvpn-2.3.14/sample/sample-config-filesディレクトリ以下にサンプルファイルが用意されています。

▶ **/etc/openvpn/server.confの主な設定**
```
# ポート番号とプロトコル
port 1194
proto udp

# ルーティングならtun
dev tap0

# 認証局証明書のファイル名
# (設定ファイルのあるディレクトリを起点とした相対パスまたは絶対パス)
ca keys/ca.crt

# サーバ証明書のファイル名
cert keys/server.crt

# サーバ秘密鍵のファイル名
key keys/server.key

# DHパラメータのファイル名
dh keys/dh2048.pem

# OpenVPNクライアントへ渡す情報
push "route 192.168.1.1 255.255.255.0"

# 実行ユーザーとグループ
user nobody
group nobody

# 接続中のクライアントのリストを出力するファイル
status /var/log/openvpn-status.log

# ログを出力するファイル(指定しなければsyslog)
log /var/log/openvpn.log
```

OpenVPNはUDPポート1194を使うので、ルータやファイヤウォールで1194番ポートを許可する設定をしておく必要があります。また、IPパケットのフォワーディングを有効にしておきます。

```
# echo 1 > /proc/sys/net/ipv4/ip_forward
```

OpenVPNサービスを起動します。
```
# systemctl start openvpn-bridge
```

## 14.6.4 OpenVPNクライアントの設定

OpenVPNクライアントも、サンプルファイルをコピーして設定するとよいでしょう。主な設定箇所を次に示します。
▶ **/etc/openvpn/client.confの主な設定**
```
# プロトコル
proto udp

# ルーティングならtun
dev tap0

# クライアントであることの指定
client

# 接続先サーバおよびポート
remote centos7.example.com 1194

# 認証局証明書のファイル名
ca keys/ca.crt

# クライアント証明書のファイル名
cert keys/client.crt

# クライアント秘密鍵のファイル名
key keys/client.key

```

OpenVPNクライアントを起動します。

```
# /usr/sbin/openvpn /etc/openvpn/client.conf
```
**注意**
OpenVPNの設定や実際の手順はディストリビューションやバージョンによって異なります。具体的な設定や運用については、各ディストリビューションのドキュメントを参照してください。